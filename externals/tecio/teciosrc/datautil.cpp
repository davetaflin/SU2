#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "TASSERT.h"
#include "Q_UNICODE.h"
#include "SYSTEM.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "SET.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "DATAIO.h"
#include "DATAIO4.h"
#include "DATAUTIL.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined MAKEARCHIVE
 #define ___1937
 #endif
#include "INPUT.h"
using namespace tecplot;
 #if defined MAKEARCHIVE
 #define ___58 1.0e-10
void ___1935(void) { LineThicknessInputSpec.___4236                                = ___1942; LineThicknessInputSpec.___2470                                 = 0.000001; LineThicknessInputSpec.___2346                                 = 1.0; LineThicknessInputSpec.___1978.___3434           = 100.0; LineThicknessInputSpec.___3884                      = NULL; PatternLengthInputSpec.___4236                                = ___1942; PatternLengthInputSpec.___2470                                 = 0.0001; PatternLengthInputSpec.___2346                                 = 1.0; PatternLengthInputSpec.___1978.___3434           = 100.0; PatternLengthInputSpec.___3884                      = NULL; TextBoxMarginInputSpec.___4236                                = ___1942; TextBoxMarginInputSpec.___2470                                 = 0.0; TextBoxMarginInputSpec.___2346                                 = 20.0; TextBoxMarginInputSpec.___1978.___3434           = 100.0; TextBoxMarginInputSpec.___3884                      = NULL; TextLineSpacingInputSpec.___4236                              = ___1942; TextLineSpacingInputSpec.___2470                               = 0.0; TextLineSpacingInputSpec.___2346                               = 5.0; TextLineSpacingInputSpec.___1978.___3434         = 1.0; TextLineSpacingInputSpec.___3884                    = NULL; ArrowheadSizeInputSpec.___4236                                = ___1942; ArrowheadSizeInputSpec.___2470                                 = 0.0; ArrowheadSizeInputSpec.___2346                                 = 0.5; ArrowheadSizeInputSpec.___1978.___3434           = 100.0; ArrowheadSizeInputSpec.___3884                      = NULL; TextAngleInputSpec.___4236                                    = ___1942; TextAngleInputSpec.___2470                                     = -___3003 - ___58; TextAngleInputSpec.___2346                                     =  ___3003 + ___58; TextAngleInputSpec.___1978.___3434               = ___954; TextAngleInputSpec.___3884                          = NULL; ArrowheadAngleInputSpec.___4236                               = ___1942; ArrowheadAngleInputSpec.___2470                                = 1.0 / ___954 - ___58; ArrowheadAngleInputSpec.___2346                                = ___3088 + ___58; ArrowheadAngleInputSpec.___1978.___3434          = ___954; ArrowheadAngleInputSpec.___3884                     = NULL; }
 #endif
void LocalReadBlock(___1405   *___1401, double         *CurVPtr, FieldDataType_e ___1367, ___2227       ___2842, ___372      *___2040) { REQUIRE(VALID_REF(___2040) && VALID_BOOLEAN(*___2040)); REQUIRE(!(*___2040) || VALID_REF(___1401)); REQUIRE(!(*___2040) || VALID_FIELD_DATA_TYPE(___1367)); if (*___2040) { ___372 ___1099 = (CurVPtr != NULL); ___372 ReadByBlock = (___1367 == FieldDataType_Double) || !___1099; if (ReadByBlock) { ___3296(___1401, ___1099, (void *)CurVPtr, ___1367, 0, ___2842, ___2040); } else { for (___2227 N = 0; *___2040 && (N < ___2842); N++) { double const D = ___1762(___1401, ___1367, -___2179, ___2179, ___2040); if (___1099) CurVPtr[N] = D; } } } }
 #define READTEC_FREE(___3251,str) ( ((___3251)!=NULL) ? (___1530((___3251),(str)),(___3251)=NULL) : (NULL) )
___372 STDCALL ___3297( ___372       ___1748, char const*     ___1394, int32_t        *fileVersion, DataFileType_e *___1407, char          **___903, ___1172     *___2847, ___1172     *NumVars, ___3839  *___4366, ___3839  *___4653, int32_t       **zoneVersions, ___2227     **___2830, ___2227     **___2831, ___2227     **___2832, ___2227     **___2805, ZoneType_e    **___4693, ___3839  *___4285, ___264     *___885, ___2227       **neighborCount, int32_t        ***valueLocations, FieldDataType_e***___1372, ___372      ***fieldDataPassive, int32_t        ***varSharing, int32_t         **connectSharing, ___372         RawDataSpaceAllocated, ___2732      ***___2724, double         ***___4395) { REQUIRE(VALID_BOOLEAN(___1748)); REQUIRE(VALID_NON_ZERO_LEN_STR(___1394)); REQUIRE(VALID_REF(fileVersion)); REQUIRE(VALID_REF(___1407)); REQUIRE(VALID_REF(___903) || ___903 == NULL); REQUIRE(VALID_REF(___2847)); REQUIRE(VALID_REF(NumVars)); REQUIRE(___4366  == NULL || VALID_REF(___4366)); REQUIRE(___4653 == NULL || VALID_REF(___4653)); REQUIRE(zoneVersions == NULL || VALID_REF(zoneVersions)); REQUIRE(___2830   == NULL || VALID_REF(___2830)); REQUIRE(___2831   == NULL || VALID_REF(___2831)); REQUIRE(___2832 == NULL || VALID_REF(___2832)); REQUIRE(___2805 == NULL || VALID_REF(___2805)); REQUIRE(___4693 == NULL || VALID_REF(___4693)); REQUIRE(___4285   == NULL || VALID_REF(___4285)); REQUIRE(VALID_REF_OR_NULL(neighborCount) && IMPLICATION(neighborCount, *neighborCount == NULL)); REQUIRE(VALID_REF_OR_NULL(valueLocations) && IMPLICATION(valueLocations, *valueLocations == NULL)); REQUIRE(VALID_REF_OR_NULL(___1372) && IMPLICATION(___1372, *___1372 == NULL)); REQUIRE(VALID_REF_OR_NULL(fieldDataPassive) && IMPLICATION(fieldDataPassive, *fieldDataPassive == NULL)); REQUIRE(VALID_REF_OR_NULL(varSharing) && IMPLICATION(varSharing, *varSharing == NULL)); REQUIRE(VALID_REF_OR_NULL(connectSharing) && IMPLICATION(connectSharing, *connectSharing == NULL)); REQUIRE(VALID_BOOLEAN(RawDataSpaceAllocated)); REQUIRE(IMPLICATION(!___1748 && RawDataSpaceAllocated, VALID_REF(___2724) && VALID_REF(___4395))); ___372     InputIsOk = ___1305; ___134  ___4682 = NULL; ___2227    *___1441 = NULL; ___1405 *ReadTecFileStream = NULL; ___3501       *___2075 = NULL; ___372 const getDataSegmentMetaData = (___1372 || fieldDataPassive || varSharing || connectSharing || neighborCount);
 #if defined MAKEARCHIVE
___1935();
 #endif
InputIsOk  = ___2876(&ReadTecFileStream, ___1394, 0, fileVersion); if (InputIsOk) InputIsOk = ___3279(ReadTecFileStream, short(*fileVersion), ___1305, ___2847, NumVars, (int32_t *)NULL, ___903, (___4118 **)NULL, (___1632 **)NULL, (___3839  **)NULL, ___4285, ___885, 0, &___2075, (___372 *)NULL, (___372 *)NULL, &___4682, ___4366, (___134 *)NULL, (___3501 *)NULL, &___1441, ___1407); if (InputIsOk) { if (*___2847 == 0) *NumVars = 0; else if (*fileVersion > 191) { ___1177(___4217("ReadTec does not yet support version %d " "Tecplot binary data files."), *fileVersion); InputIsOk = ___1305; } else if (!___1748) { for (___1172 Z = 0; Z < *___2847 && InputIsOk; Z++) { InputIsOk = ___2015(___2075[Z]); if (!InputIsOk) ___1177(___4217("Cell centered data not supported by ReadTec.")); } } } if (InputIsOk && ___2075 && valueLocations && *___2847 > 0) { *valueLocations = ___23(*___2847, int32_t*, "valueLocations base array"); InputIsOk = (*valueLocations != NULL); for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) (*valueLocations)[zn] = NULL; for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) { (*valueLocations)[zn] = ___23(*NumVars, int32_t, "valueLocations subarray"); InputIsOk = ((*valueLocations)[zn] != NULL); for (___1172 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (___1956(___2075[zn], ___4336)) (*valueLocations)[zn][___4336] = 0; else (*valueLocations)[zn][___4336] = 1; } } } if (InputIsOk && ___1372 && *___2847 > 0) { *___1372 = ___23(*___2847, FieldDataType_e*, "fieldDataTypes base array"); InputIsOk = (*___1372 != NULL); for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) (*___1372)[zn] = NULL; } if (InputIsOk && fieldDataPassive && *___2847 > 0) { *fieldDataPassive = ___23(*___2847, ___372*, "fieldDataPassive base array"); InputIsOk = (*fieldDataPassive != NULL); for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) (*fieldDataPassive)[zn] = NULL; } if (InputIsOk && varSharing && *___2847 > 0) { *varSharing = ___23(*___2847, ___1172*, "varSharing base array"); InputIsOk = (*varSharing != NULL); for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) (*varSharing)[zn] = NULL; } if (InputIsOk && neighborCount && *___2847 > 0) { *neighborCount = ___23(*___2847, ___2227, "neighborCount array"); InputIsOk = (*neighborCount != NULL); for (___1172 zn = 0; zn < *___2847 && InputIsOk; ++zn) (*neighborCount)[zn] = 0; } if (InputIsOk && *___2847 > 0) { if (___4653) *___4653 = ___3821(); if (zoneVersions) *zoneVersions = ___23(*___2847, int32_t, "zoneVersions Array"); if (___2830) *___2830  = ___23(*___2847, ___2227, "numptsi"); if (___2831) *___2831  = ___23(*___2847, ___2227, "numptsj"); if (___2832) *___2832 = ___23(*___2847, ___2227, "numptsk"); if (___2805) *___2805 = ___23(*___2847, ___2227, "NumFaceNodes");
if (___4693) *___4693 = ___23(*___2847, ZoneType_e, "zonetype"); for (___1172 zn = 0; zn < *___2847; zn++) { ___4683* ___4677 = ___1803(___4682, zn); if (___4677 != NULL) { if (___4653 && *___4653) ___3823(*___4653, ___4677->___2686); if (zoneVersions && *zoneVersions) (*zoneVersions)[zn] = ___4677->tecplotFileZoneVersion; if (___2830 && *___2830) (*___2830)[zn] = ___4677->___2830; if (___2831 && *___2831) (*___2831)[zn] = ___4677->___2831; if (___2832 && *___2832) (*___2832)[zn] = ___4677->___2832; if (___2805 && *___2805) (*___2805)[zn] = ___4677->___2805; if (___4693 && *___4693) (*___4693)[zn] = ___4677->___4236; } else { if (___4653 && *___4653) ___3823(*___4653, NULL); if (zoneVersions && *zoneVersions) (*zoneVersions)[zn] = *fileVersion; if (___2830 && *___2830) (*___2830)[zn] = 0; if (___2831 && *___2831) (*___2831)[zn] = 0; if (___2832 && *___2832) (*___2832)[zn] = 0; if (___2805 && *___2805) (*___2805)[zn] = 0; if (___4693 && *___4693) (*___4693)[zn] = ___4703; } } } ___372 const readDataSegment = (*___2847 > 0) && (!___1748 || getDataSegmentMetaData); ___372 const allocateFieldDataAndConnectivity = (*___2847 > 0) && (!___1748 && !RawDataSpaceAllocated); if (readDataSegment && InputIsOk) { ___2227 const numZoneVars = ___2227(*___2847) * ___2227(*NumVars); ___1172      *VarSharesFromZone = NULL; ___372       *___2076               = NULL; ___1172      *ConnectivitySharesFromZone = NULL; FieldDataType_e *VarType = NULL; if (allocateFieldDataAndConnectivity) { *___4395 = ___23(numZoneVars, double *, "vdatabase array"); if (*___4395 == NULL) { ___1177(___4217("Cannot allocate space for field data")); InputIsOk = ___1305; } else { for (___2227 zv = 0; zv < numZoneVars; ++zv) (*___4395)[zv] = NULL; } if (InputIsOk) { *___2724 = ___23(*___2847, ___2732 *, "nodemap array"); if (*___2724 == NULL) { ___1177(___4217("Cannot allocate space for nodemap")); InputIsOk = ___1305; } else { for (___1172 zn = 0; zn < *___2847; ++zn) (*___2724)[zn] = NULL; } } } if (InputIsOk) { VarType           = ___23(*NumVars, FieldDataType_e, "VarType"); VarSharesFromZone = ___23(*NumVars, ___1172, "VarSharesFromZone"); ___2076      = ___23(*NumVars, ___372, "IsVarPassive"); ConnectivitySharesFromZone = ___23(*___2847, ___1172, "ConnectivitySharesFromZone"); InputIsOk = (VarType                    != NULL && VarSharesFromZone          != NULL && ___2076               != NULL && ConnectivitySharesFromZone != NULL); } for (___1172 zone = 0; zone < *___2847 && InputIsOk; ++zone) { double const ___4567 = ___1762(ReadTecFileStream, FieldDataType_Float, 0.0, 1000.0, &InputIsOk); if (InputIsOk && (___4567 == ZoneMarkerFull32Bit || ___4567 == ZoneMarkerFace64Bit)) { ___4683 *zoneSpec   = ___1803(___4682, zone); ___372   ZoneIsFinite  = (zoneSpec->___4236 != ___4704);
___372   ZoneIsFEPoly  = (zoneSpec->___4236 == ___4698 || zoneSpec->___4236 == ___4699); ___372   InBlockFormat = zoneSpec->___4647.___2027; for (___1172 ___4336 = 0; ___4336 < *NumVars; ++___4336 ) { VarSharesFromZone[___4336] = -1; VarType[___4336]           = FieldDataType_Float; ___2076[___4336]      = ___1305; } if (*fileVersion > 45 && *fileVersion < 101 && InputIsOk) { ___1172 const numDupVars = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk); if ((numDupVars > 0) && (zone == 0)) { ___1177(___4217("Cannot duplicate variables from the first zone since there are " "no previous zones to duplicate from.")); InputIsOk = ___1305; } for (___1172 index = 0; index < numDupVars && InputIsOk; ++index) { ___1172 const ___4336 = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, *NumVars, &InputIsOk) - 1; VarSharesFromZone[___4336] = zone - 1; } } if (*fileVersion >= 70 && InputIsOk) { for (___1172 ___4336 = 0; ___4336 < *NumVars; ++___4336) { VarType[___4336] = (FieldDataType_e)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___1365, &InputIsOk); if (!InputIsOk) { ___1177(___4217("Invalid data type - binary input file corrupted")); InputIsOk = ___1305; } } } ___2227 const ___2809 = InputIsOk ? zoneSpec->___2830 : 0; ___2227 const ___2814 = InputIsOk ? zoneSpec->___2831 : 0; ___2227 const ___2817 = InputIsOk ? zoneSpec->___2832 : 0; ___2227 const TotalNumPts = (ZoneIsFinite ? ___2809 : ___2809 * ___2814 * ___2817); for (___1172 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (allocateFieldDataAndConnectivity && TotalNumPts >= 1) (*___4395)[___4336 + zone*(*NumVars)] = ___23(TotalNumPts, double, "raw data"); } if (*fileVersion >= 105 && InputIsOk) { if ((___372)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1172 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { ___2076[___4336] = (___372)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); } } } if (*fileVersion >= 101 && InputIsOk) { if ((___372)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk) && InputIsOk) { for (___1172 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { ___1172 const SharedZone = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2382 - 1, &InputIsOk); if (SharedZone != -1 && InputIsOk) VarSharesFromZone[___4336] = SharedZone; } } if (InputIsOk) { ___1172 const SharedZone = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), -1, ___2382 - 1, &InputIsOk); if (InputIsOk) ConnectivitySharesFromZone[zone] = SharedZone; } } if (*fileVersion >= 103 && InputIsOk) { for (___1172 ___4336 = 0; ___4336 < *NumVars && InputIsOk; ++___4336) { if (VarSharesFromZone[___4336] == -1 && !___2076[___4336]) { ___1762(ReadTecFileStream, FieldDataType_Double, -___2179, ___2179, &InputIsOk); ___1762(ReadTecFileStream, FieldDataType_Double,
-___2179, ___2179, &InputIsOk); } } } if (___1748) { if (InBlockFormat) { for (___1172 ___4336 = 0; InputIsOk && ___4336 < *NumVars; ++___4336) { if (VarSharesFromZone[___4336] == -1 && !___2076[___4336]) { ___2227 numValues = TotalNumPts; if (___1956(___2075[zone], ___4336)) { if (ZoneIsFinite) numValues = ___2814; else if (___2809 > 1 && ___2814 > 1 && ___2817 > 1) numValues = ___2809 * ___2814 * (___2817 - 1); else if (___2809 > 1 && ___2814 > 1) numValues = ___2809 * (___2814 - 1); else if (___2814 > 1 && ___2817 > 1) numValues = ___2814 * (___2817 - 1); else if (___2809 > 1 && ___2817 > 1) numValues = ___2809 * (___2817 - 1); else if (___2809 > 1) numValues = (___2809 - 1); else if (___2814 > 1) numValues = (___2814 - 1); else if (___2817 > 1) numValues = (___2817 - 1); else numValues = 1; } LocalReadBlock( ReadTecFileStream, NULL, VarType[___4336], numValues, &InputIsOk); } } } else { ___1177(___4217("Zone in point format, not all meta data available.")); InputIsOk = ___1305; } } else if (InBlockFormat) { for (___1172 ___4336 = 0; InputIsOk && ___4336 < *NumVars; ++___4336) { if (TotalNumPts > 0) { double *CurVPtr = (*___4395)[___4336 + zone*(*NumVars)]; if (VarSharesFromZone[___4336] != -1) { ___1172 const ___3648 = VarSharesFromZone[___4336]; double *SourceVPtr = (*___4395)[___4336 + ___3648*(*NumVars)]; for (___2227 M = 0; M < TotalNumPts; M++) CurVPtr[M] = SourceVPtr[M]; } else if (!___2076[___4336]) { LocalReadBlock(ReadTecFileStream, CurVPtr, VarType[___4336], TotalNumPts, &InputIsOk); } } } if (!InputIsOk) ___1177(___4217("Invalid raw data section of binary file")); } else if (TotalNumPts > 0) { if (InputIsOk) { ___2227 N; N = 0; while (InputIsOk && (N < TotalNumPts)) { ___1172 ___718; for (___718 = 0; InputIsOk && (___718 < *NumVars); ___718++) { double *CurVPtr  = (*___4395)[___718+zone*(*NumVars)]; if (VarSharesFromZone[___718] != -1) { ___1172 ___3648 = VarSharesFromZone[___718]; double *SourceVPtr = (*___4395)[___718+___3648*(*NumVars)]; CurVPtr[N] = SourceVPtr[N]; } else if (!___2076[___718]) { double D = ___1762(ReadTecFileStream, VarType[___718], -___2179, ___2179, &InputIsOk); if (InputIsOk && CurVPtr) CurVPtr[N] = D; } } if (!InputIsOk) ___1177(___4217("Binary datafile corrupted!")); N++; } } } if (InputIsOk && *fileVersion < 101) { if (ZoneIsFinite) { ___372 DupConnectivity; if (*fileVersion > 61) DupConnectivity = (___372)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, 1, &InputIsOk); else DupConnectivity = ___1305; if (DupConnectivity) ConnectivitySharesFromZone[zone] = zone - 1; else ConnectivitySharesFromZone[zone] = -1; } else ConnectivitySharesFromZone[zone] = -1; } if (InputIsOk && ZoneIsFinite && !ZoneIsFEPoly) { ___372   SkipNodemap; ___2732  *___2707 = NULL; ___2732  *ONM = NULL; if (allocateFieldDataAndConnectivity && ___2817*___2814 >= 1) { (*___2724)[zone] = ___23(___2817 * ___2814, ___2732, "node map"); if ((*___2724)[zone] == NULL) ___1177(___4217("Cannot allocate space for connectivity list",
"See the Tecplot User's Manual for a definition of 'connectivity list'")); } if (InputIsOk && ___2724 && *___2724) ___2707 = (*___2724)[zone]; SkipNodemap = (___2707 == NULL); if (InputIsOk && ConnectivitySharesFromZone[zone] != -1) { ___1172 ___3648 = ConnectivitySharesFromZone[zone]; if (___3648 >= zone) { ___1177(___4217("Zone %d is attempting to share connectivity " "with a zone that has not yet been loaded."), zone + 1); InputIsOk = ___1305; } else { ONM = (*___2724)[___3648]; if (ONM == NULL) { ___1177(___4217("Zone %d is attempting to share connectivity " "with a zone that is not finite element."), zone + 1); InputIsOk = ___1305; } } } if (InputIsOk) { if (___1748) { if (ConnectivitySharesFromZone[zone] == -1 && *___1407 != ___848) { LocalReadBlock(ReadTecFileStream, NULL, FieldDataType_Int32, ___2814*___2817, &InputIsOk); } } else { for (___2227 ___2106 = 0; ___2106 < ___2814; ___2106++) for (___2227 ___1832 = 0; ___1832 < ___2817; ___1832++) { ___2227 ___2165 = ___2106 * ___2817 + ___1832; ___2227 M; if (ConnectivitySharesFromZone[zone] != -1) { M = ONM[___2165]; } else { int32_t const nodeShift = *fileVersion < 103 ? 1 : 0; M = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2749 + nodeShift, ___2182, &InputIsOk) - nodeShift; } if (!SkipNodemap) ___2707[___2165] = M; } } } } if (*fileVersion >= 101 && InputIsOk) { if ( ConnectivitySharesFromZone[zone] == -1 && *___1407 != ___848     && ___1441[zone] != 0 ) { if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = ___1441[zone]; ___2227 Connection = 0; while (Connection < ___1441[zone] && InputIsOk) { (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), -___2182, ___2182, &InputIsOk); if (!InputIsOk) ___1177(___4217("Unexpected end-of-file while reading face neighbor data.")); (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), -___2182, ___2182, &InputIsOk); if (InputIsOk) { ___478(zoneSpec->___1440 == ___1290  || zoneSpec->___1440 == ___1289 || zoneSpec->___1440 == ___1287 || zoneSpec->___1440 == ___1286); if (zoneSpec->___1440 == ___1290) (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2749, ___2182, &InputIsOk); else (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), -___2182, ___2182, &InputIsOk); if (zoneSpec->___1440 != ___1290 && InputIsOk) { ___2227 NumAssociations = 0; if (zoneSpec->___1440 == ___1289) { NumAssociations = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2182, &InputIsOk); } else if (zoneSpec->___1440 == ___1287) { (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2749, ___2182, &InputIsOk); } else { ___478(zoneSpec->___1440 == ___1286);
NumAssociations = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2182, &InputIsOk); } if (zoneSpec->___1440 != ___1287 && InputIsOk) { ___2227 Assoc; if (zoneSpec->___1440 == ___1289) { for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2749, ___2182, &InputIsOk); } else { ___478(zoneSpec->___1440 == ___1286); for (Assoc = 0; Assoc < NumAssociations && InputIsOk; Assoc++) { (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2750, ___2382, &InputIsOk); (void)___1750<int32_t>(ReadTecFileStream, short(*fileVersion), ___2749, ___2182, &InputIsOk); } } if (InputIsOk) Connection += NumAssociations; } else if (InputIsOk) Connection += 1; } else if (InputIsOk) Connection += 1; if (!InputIsOk) ___1177(___4217("Corrupt input file: invalid face neighbors.")); } } } } if (InputIsOk                              && ZoneIsFEPoly                           && *fileVersion >= 110                    && ConnectivitySharesFromZone[zone] == -1 && *___1407 != ___848) { if (!InBlockFormat) { ___1177(___4217("Poly zones must be in block format")); InputIsOk = ___1305; } if (InputIsOk) { ___2227 const ___2806 = zoneSpec->___2832; if (*fileVersion == 110) { zoneSpec->___2805 = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2182, &InputIsOk); zoneSpec->___2799 = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2182, &InputIsOk); zoneSpec->___2800 = ___1750<int32_t>(ReadTecFileStream, short(*fileVersion), 0, ___2182, &InputIsOk); } ___2227 const ___4193 = zoneSpec->___2805; ___2227 const TotalNumBndryFaces = zoneSpec->___2799; ___2227 const TotalNumBndryItems = zoneSpec->___2800; if (zoneSpec->___4236 == ___4699) { int64_t const numFaceMetaDataValues = (zoneSpec->tecplotFileZoneVersion >= 191) ? ___2806  : ___2806 + 1/*offsets*/; ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, numFaceMetaDataValues, &InputIsOk); } if (InputIsOk) { ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, ___4193, &InputIsOk); } if (InputIsOk) { ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, ___2806, &InputIsOk); } if (InputIsOk) { ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, ___2806, &InputIsOk); } if (TotalNumBndryFaces > 0) { ___478(*fileVersion <= 191); if (InputIsOk && *fileVersion <= 191) ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, 1, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, TotalNumBndryFaces + 1, &InputIsOk); if (InputIsOk) ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk); if (InputIsOk) { if (*fileVersion >= 112) ___3292(ReadTecFileStream, ___1305/*doRead*/, NULL, 0, TotalNumBndryItems, &InputIsOk);
else ___3290(ReadTecFileStream, ___1305 , NULL, 0, TotalNumBndryItems, &InputIsOk); } } if (InputIsOk && neighborCount && *neighborCount) (*neighborCount)[zone] = zoneSpec->___2800; } } } else { ___1177(___4217("Corrupt input file")); InputIsOk = ___1305; } if (InputIsOk && VarType && ___1372) { (*___1372)[zone] = VarType; VarType = ___23(*NumVars, FieldDataType_e, "VarType array"); InputIsOk = (VarType != NULL); } if (InputIsOk && ___2076 && fieldDataPassive) { (*fieldDataPassive)[zone] = ___2076; ___2076 = ___23(*NumVars, ___372, "IsVarPassive array"); InputIsOk = (___2076 != NULL); } if (InputIsOk && VarSharesFromZone && varSharing) { (*varSharing)[zone] = VarSharesFromZone; VarSharesFromZone = ___23(*NumVars, ___1172, "VarSharesFromZone array"); InputIsOk = (VarSharesFromZone != NULL); } } if (ConnectivitySharesFromZone) { if (connectSharing && InputIsOk) { *connectSharing = ConnectivitySharesFromZone; ConnectivitySharesFromZone = NULL; } else READTEC_FREE(ConnectivitySharesFromZone, "ConnectivitySharesFromZone"); } if (VarType) READTEC_FREE(VarType, "VarType"); if (___2076) READTEC_FREE(___2076, "IsVarPassive"); if (VarSharesFromZone) READTEC_FREE(VarSharesFromZone, "VarSharesFromZone"); if (!InputIsOk) { if (neighborCount) READTEC_FREE(*neighborCount, "neighborCount"); for (___1172 zn = 0; zn < *___2847; ++zn) { if (valueLocations && *valueLocations) READTEC_FREE((*valueLocations)[zn], "valueLocations subarray"); if (___1372 && *___1372) READTEC_FREE((*___1372)[zn], "fieldDataTypes subarray"); if (fieldDataPassive && *fieldDataPassive) READTEC_FREE((*fieldDataPassive)[zn], "fieldDataPassive subarray"); if (varSharing && *varSharing) READTEC_FREE((*varSharing)[zn], "varSharing subarray"); } if (valueLocations) READTEC_FREE(*valueLocations, "valueLocations"); if (___1372) READTEC_FREE(*___1372, "fieldDataTypes"); if (fieldDataPassive) READTEC_FREE(*fieldDataPassive, "fieldDataPassive"); if (varSharing) READTEC_FREE(*varSharing, "varSharing"); if (connectSharing) READTEC_FREE(*connectSharing, "connectSharing"); if (!RawDataSpaceAllocated) { if (___4395 && *___4395) { for (___2227 zv = 0; zv < numZoneVars; ++zv) { if ((*___4395)[zv]) READTEC_FREE((*___4395)[zv], "vdatabase array"); } READTEC_FREE(*___4395, "vdatabase pointer array"); } if (___2724 && *___2724) { for (___1172 zn = 0; zn < *___2847; ++zn) { if ((*___2724)[zn]) READTEC_FREE((*___2724)[zn], "connectivity list"); } READTEC_FREE(*___2724, "connectivity pointer array"); } } } } if (___2075) { for (___1172 zn = 0; zn < *___2847; ++zn) ___939(&___2075[zn]); READTEC_FREE(___2075, "Array of IsVarCellCentered sets"); } if (___1441 != NULL) READTEC_FREE(___1441, "FNNumBndryConns"); if (___4682) ArrayListDealloc(&___4682, ___4681, 0); if (ReadTecFileStream) { ___4195(ReadTecFileStream->File);
free(ReadTecFileStream); } ENSURE(VALID_BOOLEAN(InputIsOk)); ENSURE(IMPLICATION(neighborCount, InputIsOk == (*neighborCount != NULL))); ENSURE(IMPLICATION(valueLocations, InputIsOk == (*valueLocations != NULL))); ENSURE(IMPLICATION(___1372, InputIsOk == (*___1372 != NULL))); ENSURE(IMPLICATION(fieldDataPassive, InputIsOk == (*fieldDataPassive != NULL))); ENSURE(IMPLICATION(varSharing, InputIsOk == (*varSharing != NULL))); ENSURE(IMPLICATION(connectSharing, InputIsOk == (*connectSharing != NULL))); return InputIsOk; } void* STDCALL ___3957(size_t size) { return (void *)___23(size, char, "TecAlloc"); } void STDCALL ___3968(void *___3251) { char *Tmp = (char *)___3251; READTEC_FREE(Tmp, "TecAlloc"); }
